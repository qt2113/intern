<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>ğŸ“§ é‚®ä»¶æŠ“å–åŠä»£ç ç»´æŠ¤</title>
  <link rel="stylesheet" href="../style.css">
  <style>
    body {
      font-family: sans-serif;
      padding: 40px;
      max-width: 900px;
      margin: auto;
    }
    h1 {
      color: #2c3e50;
    }
    pre {
      background: #f4f4f4;
      padding: 15px;
      overflow-x: auto;
      border-left: 4px solid #2980b9;
    }
    code {
      font-family: monospace;
    }
    a {
      color: #2980b9;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>ğŸ“§ é‚®ä»¶æŠ“å–åŠä»£ç ç»´æŠ¤</h1>
  <p>æœ¬æ¨¡å—æ—¨åœ¨è‡ªåŠ¨åŒ–æŠ“å–å…¬å¸å‡€å€¼é‚®ç®±å†…çš„å‡€å€¼æ•°æ®ï¼ŒåŒ…å«é‚®ä»¶æ­£æ–‡ä¸­çš„è¡¨æ ¼åŠé™„ä»¶ä¸­çš„excelæ•°æ®ï¼Œå¹¶è¾“å‡ºä¸ºexcelæ–‡ä»¶ï¼Œä¾›åç»­ç»Ÿè®¡æ ¡éªŒä½¿ç”¨ã€‚</p>

  <h2>ğŸ“„ Python æºä»£ç </h2>

  <h3>ä»é‚®ä»¶æ­£æ–‡æŠ“å–å‡€å€¼.py</h3>
    <details>
        <summary>ç‚¹å‡»å±•å¼€/æŠ˜å ä»£ç </summary>
        <div style="position: relative;">
            <button onclick="copyCode(this)" style="position: absolute; top: 8px; right: 8px; z-index: 2; font-size: 12px; padding: 2px 8px; cursor: pointer;">å¤åˆ¶ä»£ç </button>
            <pre><code>
    <!-- æ›¿æ¢ä¸ºå®é™…æ–‡ä»¶å†…å®¹ -->
   # -*- coding: utf-8 -*-
    """
    Created on Tue Sep 10 13:01:24 2024
    @author: rls
    """
    import imaplib
    import email
    import os
    import rule1
    from bs4 import BeautifulSoup
    import time
    import pandas as pd
    #import datetime
    #import chardet
    #from email.utils import parseaddr
    from email.header import decode_header
    from email import utils
    from MyModules.logger import mylogger
    from MyModules.db_MySQL import MySQLClient
    from mail_config import *


    import warnings
    import sys
    import traceback
    import traceback
    warnings.filterwarnings('ignore')
    # from func_timeout import func_set_timeout
    imaplib._MAXLINE  =  10000000
    class Email:
        """æœ¬ç±»æ˜¯ä»é‚®ç®±æŠ“å–ç§å‹ŸåŸºé‡‘å‡€å€¼æ­£æ–‡"""
        def __init__(self, email_address, password, IMAP4_server="imap.exmail.qq.com"):# IMAP4_server="imap.exmail.qq.com"
            CURRENT_TIME = time.strftime('%Y-%m-%d_%H', time.localtime(time.time()))
            log_filename = os.path.splitext(os.path.basename(__file__))[0] + f'_{CURRENT_TIME}_mail.log'
            LOGS_FILEPATH = './logs'
            os.makedirs(LOGS_FILEPATH, exist_ok=True)
            self.logger = mylogger(os.path.join(LOGS_FILEPATH, log_filename))
            # try:
            #     self.db = MySQLClient(MYSQL_HOST, MYSQL_PORT, MYSQL_USER, MYSQL_PASSWORD, MYSQL_DB,self.logger)  # touyanåº“ï¼ˆå³å‡€å€¼åº“ï¼‰
            # except:
            #     print('æ•°æ®åº“é“¾æ¥å¤±è´¥ï¼')

            self.server = imaplib.IMAP4_SSL(IMAP4_server)
            self.server.login(email_address, password)
            #print(self.server.list()) çœ‹æ–‡ä»¶å¤¹çš„åå­—
            self.server.select("INBOX")# é€‰æ‹©é‚®ç®±æµ‹è¯•æ–‡ä»¶å¤¹    &UXZO1mWHTvZZOQ-/TESTBOX
            # æœç´¢åŒ¹é…çš„é‚®ä»¶ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å­—ç¬¦é›†ï¼ŒNoneé»˜è®¤å°±æ˜¯ASCIIç¼–ç ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯æŸ¥è¯¢æ¡ä»¶ï¼Œè¿™é‡Œçš„ALLå°±æ˜¯æŸ¥æ‰¾å…¨éƒ¨
            type, data = self.server.search(None, 'ALL')
        
            # é‚®ä»¶åˆ—è¡¨,ä½¿ç”¨ç©ºæ ¼åˆ†å‰²å¾—åˆ°é‚®ä»¶ç´¢å¼•
            self.msgList = data[0].split()
            self.MAIL_TIME = 'mail_time_tq_body.txt'

            # è¯»å–æˆªæ­¢é‡‡é›†æ—¶é—´
            if self.read_mail_data(self.MAIL_TIME) is not None and self.read_mail_data(self.MAIL_TIME) != '':
                self.end_time = int(self.read_mail_data(self.MAIL_TIME))
            else:
                self.end_time = self.date_to_strtotime('2020-01-01')

            self.end_time = 1577808000  # æµ‹è¯•ä»£ç 

            print('é‡‡é›†æˆªæ­¢æ—¶é—´ï¼š')
            print(self.timeStamp_to_date(self.end_time))

            #print(self.msgList)
            # å®ä¾‹åŒ–é…ç½®ä¿¡æ¯0
            # self.begin_time=self.date_to_strtotime('2024-10-17 00:00:00')
            # self.end_time=self.date_to_strtotime('2024-10-1 00:00:00')
            # print('é‡‡é›†å¼€å§‹æ—¶é—´ï¼š')
            # print(self.timeStamp_to_date(self.begin_time))
            # print('é‡‡é›†æˆªæ­¢æ—¶é—´ï¼š')
            # print(self.timeStamp_to_date(self.end_time))
        # æ ‡å‡†åŒ–æŒ‡æ ‡å
            self.mapping = {
                'goods_code': ['åŸºé‡‘ä»£ç ','äº§å“ä»£ç ','èµ„äº§ä»£ç ','åä¼šå¤‡æ¡ˆç¼–å·','å¤‡æ¡ˆç¼–ç ','TAä»£ç ','åä¼šå¤‡æ¡ˆç¼–ç ï¼ˆFund Filling Codeï¼‰'],
                'goods_name': ['åŸºé‡‘åç§°','äº§å“åç§°','èµ„äº§åç§°','åŸºé‡‘å…¨ç§°','è´¦å¥—åç§°','äº§å“åç§°ï¼ˆFund Nameï¼‰'],
                'net_time': ['å‡€å€¼æ—¥æœŸ','æ—¥æœŸ','ä¸šåŠ¡æ—¥æœŸ','ä¼°å€¼æ—¥æœŸ','ä¼°å€¼åŸºå‡†æ—¥','åŸºé‡‘å‡€å€¼æ—¥æœŸ','æœŸæœ«æ—¥æœŸ','æ—¥æœŸï¼ˆNAV As Of Dateï¼‰'],
                'dw_net': ['å•ä½å‡€å€¼','è®¡æå‰å•ä½å‡€å€¼','èµ„äº§ä»½é¢å‡€å€¼(å…ƒ)','å®é™…å‡€å€¼','Açº§å•ä½å‡€å€¼','è™šæ‹Ÿå‡€å€¼æå–å‰å•ä½å‡€å€¼','ä»½é¢å‡€å€¼','æœŸæœ«å•ä½å‡€å€¼','åŸºé‡‘ä»½é¢å‡€å€¼','è¯•ç®—å‰å•ä½å‡€å€¼','å•ä½å‡€å€¼ï¼ˆNAV/Shareï¼‰'],
                'lj_net': ['æœ€æ–°å‡€å€¼','ç´¯è®¡å•ä½å‡€å€¼','èµ„äº§ä»½é¢ç´¯è®¡å‡€å€¼(å…ƒ)','å®é™…ç´¯è®¡å‡€å€¼','èµ„äº§ä»½é¢ç´¯è®¡å‡€å€¼(å…ƒ)','åŸºé‡‘ä»½é¢ç´¯è®¡å‡€å€¼','ç´¯è®¡å‡€å€¼','Açº§å•ä½å‡€å€¼','æœŸæœ«ç´¯è®¡å‡€å€¼','è¯•ç®—å‰ç´¯è®¡å‡€å€¼','è¯•ç®—å‰ç´¯è®¡å•ä½å‡€å€¼','ç´¯è®¡å•ä½å‡€å€¼ï¼ˆAccumulated NAV/Shareï¼‰']
            }
        # å¢åŠ äº†â€œæœ€æ–°å‡€å€¼â€

        # é‚®ä»¶ç¼–ç è½¬æ¢
        def decode_str(self,s):
            value, charset = decode_header(s)[0]
            if charset:
                value = value.decode(charset)
            return value

        def date_to_strtotime(self,date):
            """æŠŠæ—¥æœŸæ ¼å¼è½¬åŒ–æˆæ—¶é—´æˆ³"""
            """æŠŠæ—¥æœŸæ ¼å¼è½¬åŒ–æˆæ—¶é—´æˆ³"""
            format = ['%Y%m%d', '%Y-%m-%d', '%Y/%m/%d', '%Y.%m.%d', '%Yå¹´%mæœˆ%dæ—¥', '%Yå¹´%mæœˆ%d', '%Y%m%d %H:%M:%S','%Y-%m-%d %H:%M:%S', '%Y/%m/%d %H:%M:%S', '%Y.%m.%d %H:%M:%S', '%Yå¹´%mæœˆ%dæ—¥ %H:%M:%S','%Yå¹´%mæœˆ%d %H:%M:%S']

            for val in format:
                try:
                    strtotime = time.strptime(date, val)
                    strtotime = int(time.mktime(strtotime))
                    return strtotime
                except:
                    continue
            return None

        def timeStamp_to_date(self,timestamp):
            """æŠŠæ—¶é—´æˆ³è½¬æ¢æˆæ—¥æœŸæ ¼å¼"""
            timeArray = time.localtime(timestamp)
            otherStyleTime = time.strftime('%Y-%m-%d %H:%M:%S',timeArray)
            return otherStyleTime
        
        def write_mail_data(self,date_time,filename):
            """å†™å…¥æˆªæ­¢é‡‡é›†æ—¥æœŸ"""
            try:
                if date_time:
                    with open(filename,'w') as f:
                        f.write(str(date_time))
                        f.close()
            except:
                print('å†™å…¥æ–‡ä»¶æ•°æ®å¤±è´¥ï¼')

        def read_mail_data(self,filename):
            """è¯»å–æˆªæ­¢é‡‡é›†æ—¥æœŸ"""
            try:
                with open(filename,'r') as f:
                    times = f.read()
                    f.close()
                    return times
            except Exception as e:
                print('è¯»å–æ–‡ä»¶æ•°æ®å¤±è´¥ï¼Œé”™è¯¯å¦‚ä¸‹ï¼š',e)
                return None


        def get_result(self,df1):
            global res
        
            res=pd.concat([res,df1])
            return res
        
        # è§£ç 
        def decodeStr(self,s):
            try:
                subject = email.header.decode_header(s)
            except:
                return None
            sub_bytes = subject[0][0]
            sub_charset = subject[0][1]
            if None == sub_charset:
                subject = sub_bytes
            elif 'unknown-8bit' == sub_charset:
                subject = str(sub_bytes, 'utf8')
            else:
                subject = str(sub_bytes, sub_charset)
            return subject


        # æ£€æµ‹ç¼–ç 
        def guessCharset(self,msg):
            charset = msg.get_charset()
            if charset is None:
                content_type = msg.get('Content-Type', '').lower()
                pos = content_type.find('charset=')
                if pos >= 0:
                    charset = content_type[pos + 8:].strip()
            return charset
        
        # è§£ææ­£æ–‡
        def parseBody(self,msg, indent=0):
            # å¦‚æœæ˜¯å¤šé‡ç»“æ„ï¼Œåˆ™è¿›å…¥è¯¥ç»“æ„
            if msg.is_multipart():
                parts = msg.get_payload()
                for n, part in enumerate(parts):
                    self.parseBody(part, indent + 1)
            else:
                content_type = msg.get_content_type()
                # è¡¨æ ¼çš„æ ¼å¼ä¸ºhtmlï¼Œå› æ­¤æŸ¥æ‰¾è¡¨å¤´ä¸ºâ€˜text/htmlâ€™çš„å†…å®¹
                if content_type == 'text/html':
                    content = msg.get_payload(decode=True)
                    charset = self.guessCharset(msg)
                    if charset:
                        content = content.decode(charset)
                    global htmltext
                    htmltext = content


        # å¯¹æŒ‡æ ‡åç§°è¿›è¡Œæ˜ å°„
        def map_column(self,col):
            for new_col, old_cols in self.mapping.items():
                if col in old_cols:
                    return new_col
            return col

        # è·å¾—æ ‡é¢˜
        def getHeading(self,msg):
            sub = msg.get('Subject')
            return self.decodeStr(sub)

        def showMaxFactor(self,num):
            count = num / 2
            while count > 1:
                if num % count == 0:
                    return count
                    break
                count -= 1

        # æå–æ•°æ®å¹¶å­˜å‚¨åˆ°è¡¨æ ¼ä¸­
        def extractData(self, msg):
            global htmltext
            self.parseBody(msg)
            soup = BeautifulSoup(htmltext, 'html.parser')
            table = soup.find('table')
            title = self.getHeading(msg)
            received = msg.get('Date')
            try:
                sent_ts = utils.parsedate(received)
                mail_time = self.timeStamp_to_date(int(time.mktime(sent_ts)))
            except Exception:
                mail_time = received

            if not table:
                self._append_result(mail_time, title, "æœªè¯†åˆ«åˆ°è¡¨æ ¼")
                return None

            rows = table.find_all('tr')
            if len(rows) < 2:
                print('è¡¨æ ¼è¡Œæ•°ä¸è¶³')
                return None

            header = [cell.get_text(strip=True) for cell in rows[0].find_all(['th', 'td'])]
            data = []
            for row in rows[1:]:
                cells = [cell.get_text(strip=True) for cell in row.find_all(['td', 'th'])]
                if not cells:
                    continue
                if len(cells) < len(header):
                    cells += [None] * (len(header) - len(cells))
                data.append(cells[:len(header)])

            if not data:
                print('è¡¨å¤´æˆ–æ•°æ®è¡Œä¸ºç©º')
                return None

            df = pd.DataFrame(data, columns=[self.map_column(col) for col in header])
            required = ['net_time', 'goods_code', 'goods_name', 'dw_net', 'lj_net']
            for col in required:
                if col not in df.columns:
                    df[col] = None
            result = df[required]

            if result.empty or all(result.iloc[0][col] in [None, '', 'None'] for col in required):
                self._append_result(mail_time, title, "æœªèƒ½è¯†åˆ«åˆ°å‡€å€¼ç›¸å…³å­—æ®µ")
                return None

            print(f'è§£ææˆåŠŸï¼Œåˆ—å: {result.columns.tolist()}, æ•°æ®: \n{result.to_string()}')
            return result

        def _append_result(self, mail_time, title, remark):
            output = {
                "net_time": mail_time,
                "goods_code": None,
                "goods_name": None,
                "dw_net": None,
                "lj_net": None,
                "å¤‡æ³¨": f"{remark}ï¼Œé‚®ä»¶æ ‡é¢˜: {title}, æ—¥æœŸ: {mail_time}"
            }
            if not hasattr(self, 'all_results'):
                self.all_results = []
            self.all_results.append(output)
            folder_path = os.path.dirname(os.path.abspath(sys.argv[0]))
            excel_path = os.path.join(folder_path, "é‚®ä»¶æ­£æ–‡å‡€å€¼æŠ“å–.xlsx")
            pd.DataFrame(self.all_results).to_excel(excel_path, index=False)
            print(f"å·²å®æ—¶è¾“å‡ºåˆ°: {excel_path}")

        def insert_data(self, result):
            if result is None or result.empty:
                return False
            n_time = str(result.loc[0, 'net_time'])
            net_time = self.date_to_strtotime(n_time)
            goods_code = str(result.loc[0, 'goods_code'])
            goods_name = str(result.loc[0, 'goods_name'])
            dw_net = str(result.loc[0, 'dw_net'])
            lj_net = str(result.loc[0, 'lj_net'])
            _insert_data = {}

            if not net_time: return False
            _insert_data['net_time'] = net_time
            if not goods_code: return False
            _insert_data['goods_code'] = goods_code
            if not goods_name: return False
            _insert_data['goods_name'] = goods_name
            if not dw_net: return False
            _insert_data['dw_net'] = eval(dw_net)
            if not lj_net: return False
            _insert_data['lj_net'] = eval(lj_net)

            _insert_data.update({'fq_net': 0, 'add_time': int(time.time()), 'source': 3, 'is_sync': 0})
            is_exists = self.db.query_one(TQ_CJ_NET_TABLE, 'count(*) as count',
                                        'where goods_code="%s" and net_time=%d' % (goods_code, _insert_data['net_time']))
            print('is_exists: ', is_exists)
            if is_exists[0] > 0:
                self.db.update(TQ_CJ_NET_TABLE, _insert_data,
                            'where goods_code="%s" and net_time=%d' % (goods_code, _insert_data['net_time']))
            else:
                self.db.insert_one(TQ_CJ_NET_TABLE, _insert_data)
            print('å‡€å€¼æ›´æ–°å®Œæˆ~')

        def get_mail(self):
            try:
                is_write_mail_time = False
                all_results = getattr(self, 'all_results', [])
                for i in range(len(self.msgList), 0, -1):
                    latest = self.msgList[i-1]
                    print(i, latest)
                    typ, datas = self.server.fetch(latest, '(RFC822)')
                    if not datas or datas == 'nan':
                        print("é‚®ä»¶æ•°æ®è·å–å¤±è´¥ï¼Œè·³è¿‡")
                        continue
                    try:
                        raw = email.message_from_bytes(datas[0][1])
                    except Exception as es:
                        print('è§£æé‚®ä»¶åŸå§‹å†…å®¹å¤±è´¥:', es)
                        continue
                    try:
                        subject = email.header.decode_header(raw.get('subject'))
                        mail_coding = subject[0][1] or 'gbk'
                        text = datas[0][1].decode(mail_coding, 'ignore')
                    except Exception as es:
                        print('ç¼–ç å‡ºé”™', es)
                        continue
                    message = email.message_from_string(text)
                    title = self.decode_str(message.get('Subject', ''))
                    print('å½“å‰é‚®ä»¶æ˜¯ï¼š' + str(title))
                    try:
                        received = message['Date']
                        sent_ts = utils.parsedate(received)
                        mail_time = int(time.mktime(sent_ts))
                        mail_time_str = self.timeStamp_to_date(mail_time)
                        print('å½“å‰é‚®ä»¶æ¥æ”¶æ—¶é—´æ˜¯ï¼š' + mail_time_str)
                    except Exception as es:
                        print('é‚®ä»¶æ¥æ”¶æ—¶é—´å‡ºé”™', es)
                        continue
                    if mail_time is not None and mail_time <= self.end_time:
                        print('åˆ°è¾¾é‡‡é›†ç»ˆç‚¹ï¼Œåœæ­¢é‡‡é›†ï¼')
                        break
                    if not is_write_mail_time and mail_time is not None:
                        self.write_mail_data(mail_time, self.MAIL_TIME)
                        is_write_mail_time = True
                    try:
                        self.parseBody(message)
                        result = self.extractData(message)
                        print('ä»extractDataå‡½æ•°è¿”å›çš„æ•°æ®ï¼š\n')
                        if result is not None and not result.empty:
                            print('\t'.join(result.columns))
                            for _, row in result.iterrows():
                                print('\t'.join(str(x) for x in row))
                            for _, row in result.iterrows():
                                output = {col: str(row.get(col, None)) for col in ["net_time", "goods_code", "goods_name", "dw_net", "lj_net"]}
                                output["å¤‡æ³¨"] = "æŠ“å–æˆåŠŸ"
                                all_results.append(output)
                        else:
                            output = {
                                "net_time": mail_time_str,
                                "goods_code": None,
                                "goods_name": None,
                                "dw_net": None,
                                "lj_net": None,
                                "å¤‡æ³¨": f"extractDataè¿”å›ç©ºæˆ–Noneï¼Œé‚®ä»¶æ ‡é¢˜: {title}, æ—¥æœŸ: {mail_time_str}"
                            }
                            all_results.append(output)
                        folder_path = os.path.dirname(os.path.abspath(sys.argv[0]))
                        excel_path = os.path.join(folder_path, "é‚®ä»¶æ­£æ–‡å‡€å€¼æŠ“å–.xlsx")
                        pd.DataFrame(all_results).to_excel(excel_path, index=False)
                        print(f"å·²å®æ—¶è¾“å‡ºåˆ°: {excel_path}")
                    except Exception as e:
                        print('æŠ¥é”™äº†ï¼Œé”™è¯¯ä¿¡æ¯å¦‚ä¸‹1ï¼š')
                        print(e)
                        traceback.print_exc()
                        continue
                    time.sleep(1)
                    print('=' * 70)
                self.all_results = all_results
            except Exception as e:
                print('æŠ¥é”™äº†ï¼Œé”™è¯¯ä¿¡æ¯å¦‚ä¸‹2ï¼š')
                print(e)
                traceback.print_exc()
            self.server.close()
            self.server.logout()


    if __name__ == '__main__':
        # res=pd.DataFrame(columns=["goods_code","goods_name","net_time","dw_net","lj_net"])#ç”¨æ¥å­˜ç»“æœ
        while True:
            # æ³¨ï¼šEmailå¯¹è±¡å®ä¾‹åŒ–å¦‚æœæ”¾åœ¨whileå¤–é¢åªä¼šåˆå§‹åŒ–ä¸€æ¬¡é‚®ç®±ç™»å½•ã€æ•°æ®åº“è¿æ¥ã€é‡‡é›†æˆªæ­¢æ—¶é—´è¯»å–ï¼Œä¸ºä¿è¯å¥æŸ„èµ„æºå¯ç”¨æœ€å¥½æ”¾åœ¨å¾ªç¯ä½“å†…ï¼
            #Email("1832703548@qq.com", "hqmutbdipgghecei")("1349115004@qq.com", "wkmryuorksodihch")("jz@dingshi.net", "FRaYwArtZMhhuCAP")
            email_obj =  Email("jz@dingshi.net", "uJLygjCC9sDhxg4q")
            email_obj.get_mail()


            print('æœ¬æ¬¡é‡‡é›†ç»“æŸï¼Œç­‰å¾…5åˆ†é’Ÿåé‡æ–°é‡‡é›†ï¼')
            print('æœ¬æ¬¡é‡‡é›†æ—¶é—´æ˜¯ï¼š',time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))
            time.sleep(300)
            #res.to_excel('resultaaa.xlsx')
            </code></pre>
        </div>
    </details>
    <script>
    function copyCode(btn) {
            const pre = btn.parentElement.querySelector('pre code');
            let text = pre.innerText;
            // Remove leading/trailing empty lines
            text = text.replace(/^\s*\n/, '').replace(/\n\s*$/, '');
            // Create a temporary textarea to copy
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                    document.execCommand('copy');
                    btn.textContent = 'å·²å¤åˆ¶!';
                    setTimeout(() => { btn.textContent = 'å¤åˆ¶ä»£ç '; }, 1200);
            } catch (e) {
                    btn.textContent = 'å¤åˆ¶å¤±è´¥';
            }
            document.body.removeChild(textarea);
    }
    </script>

  <h3>get_qq_mail_tq.py</h3>
    <details>
        <summary>ç‚¹å‡»å±•å¼€/æŠ˜å ä»£ç </summary>
        <div style="position: relative;">
            <button onclick="copyCode(this)" style="position: absolute; top: 8px; right: 8px; z-index: 2; font-size: 12px; padding: 2px 8px; cursor: pointer;">å¤åˆ¶ä»£ç </button>
            <pre><code>
    <!-- æ›¿æ¢ä¸ºå®é™…æ–‡ä»¶å†…å®¹ -->
    import getpass,imaplib
    import email
    import os
    import time
    import pandas as pd
    import datetime
    import chardet
    from email.header import Header
    from email.mime.text import MIMEText
    from email.utils import parseaddr,formataddr
    from email.header import decode_header
    import datetime
    import random
    from email import utils
    from MyModules.mail_analysis_tq import Format
    from MyModules.logger import mylogger
    from MyModules.thread_pool import BoundedThreadPoolExecutor
    from MyModules.user_agent_list import USER_AGENT_LIST
    from MyModules.db_MySQL import MySQLClient
    from mail_config import *
    import warnings
    warnings.filterwarnings('ignore')
    imaplib._MAXLINE = 20000000

    class Email:
        """æœ¬ç±»æ˜¯ä»jz@dingshi.neté‚®ç®±æŠ“å–åŸºé‡‘å‡€å€¼ï¼ˆå±äºæŠ•å‰è·Ÿè¸ªæ ‡çš„çš„å‡€å€¼ï¼‰"""
        def __init__(self, email_address, password, IMAP4_server="imap.exmail.qq.com"):
            CURRENT_TIME = time.strftime('%Y-%m-%d_%H', time.localtime(time.time()))
            log_filename = os.path.splitext(os.path.basename(__file__))[0] + f'_{CURRENT_TIME}_mail.log'
            LOGS_FILEPATH = './logs'
            os.makedirs(LOGS_FILEPATH, exist_ok=True)
            self.logger = mylogger(os.path.join(LOGS_FILEPATH, log_filename))
            # try:
            #     self.db = MySQLClient(MYSQL_HOST, MYSQL_PORT, MYSQL_USER, MYSQL_PASSWORD, MYSQL_DB, self.logger)# touyanåº“ï¼ˆå³å‡€å€¼åº“ï¼‰
            # except:
            #     print('æ•°æ®åº“é“¾æ¥å¤±è´¥ï¼')

            self.server = imaplib.IMAP4_SSL(IMAP4_server)
            self.server.login(email_address, password)
            self.server.select("INBOX")# é€‰æ‹©é‚®ç®±é»˜è®¤æ–‡ä»¶å¤¹
            # æœç´¢åŒ¹é…çš„é‚®ä»¶ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å­—ç¬¦é›†ï¼ŒNoneé»˜è®¤å°±æ˜¯ASCIIç¼–ç ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯æŸ¥è¯¢æ¡ä»¶ï¼Œè¿™é‡Œçš„ALLå°±æ˜¯æŸ¥æ‰¾å…¨éƒ¨
            type, data = self.server.search(None, "ALL")
            # é‚®ä»¶åˆ—è¡¨,ä½¿ç”¨ç©ºæ ¼åˆ†å‰²å¾—åˆ°é‚®ä»¶ç´¢å¼•
            self.msgList = data[0].split()
            # å®ä¾‹åŒ–é…ç½®ä¿¡æ¯0
            self.mc = Format()
            self.MAIL_TIME = 'mail_time_tq.txt'
            # è¯»å–æˆªæ­¢é‡‡é›†æ—¶é—´
            if self.read_mail_data(self.MAIL_TIME) is not None and self.read_mail_data(self.MAIL_TIME) != '':
                self.end_time = int(self.read_mail_data(self.MAIL_TIME))
            else:
                self.end_time = self.date_to_strtotime(self.mc.END_TIME)
            
            self.end_time = 1577808000# æµ‹è¯•ä»£ç 
            print('é‡‡é›†æˆªæ­¢æ—¶é—´ï¼š')
            print(self.timeStamp_to_date(self.end_time))

        # é‚®ä»¶ç¼–ç è½¬æ¢
        def decode_str(self,s):
            value, charset = decode_header(s)[0]
            if charset:
                value = value.decode(charset)
            return value

        def trans_format(self,time_str):
            GMT_FORMAT = "%a, %d %b %Y %H:%M:%S %z"
            return datetime.strptime(time_str, GMT_FORMAT)


        def date_to_strtotime_bak(self, date):
            """æŠŠæ—¥æœŸæ ¼å¼è½¬åŒ–æˆæ—¶é—´æˆ³"""
            if isinstance(date, datetime):
                date = date.strftime('%Y-%m-%d %H:%M:%S')

            strtotime = time.strptime(date, '%Y-%m-%d %H:%M:%S')
            return int(time.mktime(strtotime))

        def date_to_strtotime(self, date, index=0):
            """æŠŠæ—¥æœŸæ ¼å¼è½¬åŒ–æˆæ—¶é—´æˆ³"""
            format = [
                '%Y-%m-%d %H:%M:%S', '%Y-%m-%d', '%Y/%m/%d', '%Y.%m.%d',
                '%Yå¹´%mæœˆ%dæ—¥', '%Yå¹´%mæœˆ%d', '%Y%m%d %H:%M:%S', '%Y%m%d',
                '%Y/%m/%d %H:%M:%S', '%Y.%m.%d %H:%M:%S',
                '%Yå¹´%mæœˆ%dæ—¥ %H:%M:%S', '%Yå¹´%mæœˆ%d %H:%M:%S'
            ]

            # å¦‚æœ date æ˜¯ datetime å¯¹è±¡ï¼Œå…ˆè½¬æˆå­—ç¬¦ä¸²
            if isinstance(date, datetime):
                date = date.strftime('%Y-%m-%d %H:%M:%S')

            if index >= len(format):
                return None

            try:
                strtotime = time.strptime(date, format[index])
                return int(time.mktime(strtotime))
            except:
                return self.date_to_strtotime(date, index + 1)
            

        def timeStamp_to_date(self,timestamp):
            """æŠŠæ—¶é—´æˆ³è½¬æ¢æˆæ—¥æœŸæ ¼å¼"""
            timeArray = time.localtime(timestamp)
            otherStyleTime = time.strftime('%Y-%m-%d %H:%M:%S',timeArray)
            return otherStyleTime

        # æ£€æµ‹é‚®ä»¶ç¼–ç 
        def guess_charset(self,msg):
            # å…ˆä»msgå¯¹è±¡è·å–ç¼–ç 
            charset = msg.get_charset()
            if charset is None:
                # å¦‚æœè·å–ä¸åˆ°ï¼Œå†ä»Content-Typeå­—æ®µè·å–
                content_type = msg.get('Content-Type', '').lower()
                pos = content_type.find('charset=')
                if pos >= 0:
                    # å»æ‰å°¾éƒ¨ä¸ä»£è¡¨ç¼–ç çš„å­—æ®µ
                    charset = content_type[pos + 8:].strip('; format=flowed; delsp=yes')
            return charset

        # ä½¿ç”¨å…¨å±€å˜é‡æ¥ä¿å­˜é‚®ä»¶å†…å®¹
        mail_content = '\n'

        def detect_encoding(self,file_path):
            """åˆ©ç”¨chardetçŒœæµ‹æ–‡ä»¶ç¼–ç """
            with open(file_path,'rb') as f:
                result = chardet.detect(f.read())
                return result['encoding']


        # indentç”¨äºç¼©è¿›æ˜¾ç¤º:
        def print_info(self,msg, indent=0):
            """å¾ªç¯éå†è¯»å–é‚®ä»¶"""
            global mail_content
            if indent == 0:
                for header in ['From', 'To', 'Subject']:
                    value = msg.get(header, '')
                    if value:
                        if header == 'Subject':
                            value = self.decode_str(value)
                        else:
                            hdr, addr = parseaddr(value)
                            name = self.decode_str(hdr)
                            value = u'%s <%s>' % (name, addr)
                    mail_content += '%s%s: %s' % ('  ' * indent, header, value) + '\n'

            parts = msg.get_payload()

            for n, part in enumerate(parts):
                content_type = part.get_content_type()
                if content_type == 'text/plain':
                    content = part.get_payload(decode=True)
                    charset = self.guess_charset(msg)
                    # charset = 'utf-8'
                    if charset:
                        content = content.decode(charset)
                    mail_content += '%sText:\n %s' % (' ' * indent, content)
                else:
                    # è¿™é‡Œæ²¡æœ‰è¯»å–étext/plainç±»å‹çš„å†…å®¹ï¼Œåªæ˜¯è¯»å–äº†å…¶æ ¼å¼ï¼Œä¸€èˆ¬ä¸ºtext/html
                    mail_content += '%sAttachment: %s' % ('  ' * indent, content_type)
            return mail_content


        def get_mail_file(self, message):
            """æå–é‚®ä»¶ä¸­çš„Excelé™„ä»¶å†…å®¹ï¼Œç™»è®°éExcelé™„ä»¶ã€‚"""
            result = []
            non_excel_attachments = []
            has_excel = False

            subject = self.decode_str(message.get('Subject', ''))

            mail_time = ''
            try:
                received = message['Received'].split(';')[-1]
                sent_ts = email.utils.parsedate(received)
                mail_time = time.strftime('%Y/%m/%d %H:%M', time.localtime(time.mktime(sent_ts)))
            except Exception:
                pass

            parts_info = []
            for part in message.walk():
                filename = part.get_filename()
                if filename:
                    filename_decoded = self.decode_str(filename)
                    is_excel = filename_decoded.lower().endswith(('.xls', '.xlsx'))
                    parts_info.append((part, filename_decoded, is_excel))
                    if is_excel:
                        has_excel = True

            if has_excel:
                for part, filename_decoded, is_excel in parts_info:
                    if is_excel:
                        try:
                            from io import BytesIO
                            sheets = pd.read_excel(BytesIO(part.get_payload(decode=True)), sheet_name=None, header=None)

                            for sheet_name, raw_data in sheets.items():
                                raw_data = raw_data.applymap(
                                    lambda x: x.strftime('%Y-%m-%d %H:%M:%S') if isinstance(x, datetime.datetime)
                                    else (str(x).strip() if pd.notna(x) else '')
                                )

                                parsed_data = self.mc.index(raw_data.values)
                                
                                # å¤„ç†ç¼ºé™·2ï¼šåªä¿ç•™æ¯ä¸ª goods_name æœ€æ–°æ—¥æœŸçš„è®°å½•
                                latest_data = {}
                                for item in parsed_data:
                                    if not isinstance(item, dict):
                                        continue
                                    name = item.get('goods_name')
                                    date = item.get('net_time')
                                    if name and date:
                                        if name not in latest_data or date > latest_data[name]['net_time']:
                                            latest_data[name] = item
                                
                                if latest_data:
                                    result.append(list(latest_data.values()))
                                    print(f"æˆåŠŸè§£æExcelé™„ä»¶ {filename_decoded} - Sheet: {sheet_name}: {list(latest_data.values())}")
                                else:
                                    print(f"è§£æåæ— æœ‰æ•ˆæ•°æ®ï¼š{filename_decoded} - Sheet: {sheet_name}")

                        except Exception as e:
                            print(f"è¯»å–Excelå¤±è´¥: {e}")
                return result

            # æ²¡æœ‰Excelï¼Œç™»è®°éexcelé™„ä»¶
            for part, filename_decoded, is_excel in parts_info:
                if not is_excel:
                    non_excel_attachments.append({
                        'æ ‡çš„/é‚®ä»¶æ ‡é¢˜': subject,
                        'é™„ä»¶ç±»å‹': os.path.splitext(filename_decoded)[-1][1:],
                        'é‚®ä»¶æ¥æ”¶æ—¶é—´': mail_time
                    })

            if non_excel_attachments:
                output_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'éexcelé™„ä»¶ç™»è®°è¡¨.xlsx')
                df_new = pd.DataFrame(non_excel_attachments)
                try:
                    if os.path.exists(output_path):
                        df_existing = pd.read_excel(output_path)
                        df_combined = pd.concat([df_existing, df_new], ignore_index=True)
                    else:
                        df_combined = df_new
                    df_combined.to_excel(output_path, index=False)
                    print(f"éexcelé™„ä»¶å·²ç™»è®°è¾“å‡ºåˆ°: {output_path}")
                except Exception as e:
                    print(f"å†™å…¥Excelå¤±è´¥: {e}")

            return result

        

        def write_mail_data(self, date_time, filename):
            """å†™å…¥æˆªæ­¢é‡‡é›†æ—¥æœŸ"""
            try:
                if date_time:
                    with open(filename, 'w') as f:
                        f.write(str(date_time))
            except Exception:
                print('å†™å…¥æ–‡ä»¶æ•°æ®å¤±è´¥ï¼')

        def read_mail_data(self, filename):
            """è¯»å–æˆªæ­¢é‡‡é›†æ—¥æœŸ"""
            try:
                with open(filename, 'r') as f:
                    return f.read()
            except Exception as e:
                print('è¯»å–æ–‡ä»¶æ•°æ®å¤±è´¥ï¼Œé”™è¯¯å¦‚ä¸‹ï¼š')
                print(e)
                return None

        def sort_data(self, lists):
            """å¯¹å‡€å€¼åˆ—è¡¨å‡åºæ’åº"""
            temp = [v for val in lists for v in (val if isinstance(val, list) else [val])]
            for i in range(len(temp)):
                for j in range(i + 1, len(temp)):
                    try:
                        if temp[i]['net_time'] > temp[j]['net_time']:
                            temp[i], temp[j] = temp[j], temp[i]
                    except Exception as e:
                        print('æ’åºå‡½æ•°ä¸­,æ—¥æœŸæ¯”è¾ƒæŠ¥é”™,é”™è¯¯ä¿¡æ¯å¦‚ä¸‹:')
                        print(e)
            return temp

        def get_mail(self):
            """è¯»å–é‚®ä»¶ï¼Œä»ç¬¬5375å°å¼€å§‹ï¼Œå‘å‰ï¼ˆæ›´æ—©ï¼‰æ£€ç´¢æ—¶é—´æ—©è¿‡å®ƒçš„ï¼ˆå³5375, 5374, 5373...ï¼‰"""
            try:
                is_write_mail_time = False
                # ç”¨äºæ”¶é›†æ‰€æœ‰æœ‰æ•ˆæ•°æ®çš„åˆ—è¡¨
                all_valid_data = []
                
                for i in range(len(self.msgList), 0, -1):
                    latest = self.msgList[i - 1]  # UIDS
                    print(i)  # æ‰“å°é‚®ä»¶ç´¢å¼•
                    type, datas = self.server.fetch(latest, '(RFC822)')

                    if datas is None or datas == 'nan':
                        continue

                    try:
                        raw = email.message_from_bytes(datas[0][1])
                    except Exception as es:
                        raw = None
                        print(es)

                    if raw is None:
                        continue

                    try:
                        subject = email.header.decode_header(raw.get('subject'))
                        mail_coding = subject[0][1]  # è·å¾—å½“å‰é‚®ä»¶ç¼–ç 
                        text = datas[0][1].decode(mail_coding, 'ignore')
                    except Exception as es:
                        print('ç¼–ç å‡ºé”™', es)
                    message = email.message_from_string(text)
                    title = self.decode_str(message.get('Subject', ''))
                    print('å½“å‰é‚®ä»¶æ˜¯ï¼š' + title)

                    try:
                        received = message['Received'].split(';')[-1]
                        sent_ts = utils.parsedate(received)
                        mail_time = int(time.mktime(sent_ts))
                    except Exception as te:
                        print(te, 'è¯»ä¸åˆ°é‚®ä»¶æ—¶é—´ï¼Œè·³è¿‡~')
                        self.log_failed_email(title, 0, f"Failed to read mail time: {te}")
                        continue

                    print('å½“å‰é‚®ä»¶æ¥æ”¶æ—¶é—´æ˜¯ï¼š' + self.timeStamp_to_date(mail_time))

                    if mail_time <= self.end_time:
                        print('åˆ°è¾¾é‡‡é›†ç»ˆç‚¹ï¼Œåœæ­¢é‡‡é›†ï¼')
                        break

                    if not is_write_mail_time:
                        self.write_mail_data(mail_time, self.MAIL_TIME)
                        is_write_mail_time = True

                    result = self.get_mail_file(message)
                    if not result or (len(result) == 1 and result[0] is None):
                        has_attachment = any(
                            part.get_content_disposition() == 'attachment' or part.get_filename()
                            for part in message.walk()
                        )
                        if not has_attachment:
                            self.log_failed_email(title, mail_time, "é‚®ä»¶æ²¡æœ‰ä»»ä½•é™„ä»¶")
                            non_excel_attachments = [{
                                'æ ‡çš„/é‚®ä»¶æ ‡é¢˜': title,
                                'é™„ä»¶ç±»å‹': 'æœªæ£€æµ‹åˆ°é™„ä»¶',
                                'é‚®ä»¶æ¥æ”¶æ—¶é—´': self.timeStamp_to_date(mail_time)
                            }]
                            output_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'éexcelé™„ä»¶ç™»è®°è¡¨.xlsx')
                            df_new = pd.DataFrame(non_excel_attachments)
                            try:
                                if os.path.exists(output_path):
                                    df_existing = pd.read_excel(output_path)
                                    df_combined = pd.concat([df_existing, df_new], ignore_index=True)
                                else:
                                    df_combined = df_new
                                df_combined.to_excel(output_path, index=False)
                                print(f"æœªæ£€æµ‹åˆ°é™„ä»¶ï¼Œå·²ç™»è®°è¾“å‡ºåˆ°: {output_path}")
                            except Exception as e:
                                print(f"å†™å…¥Excelå¤±è´¥: {e}")
                        else:
                            has_excel = any(
                                self.decode_str(part.get_filename()).lower().endswith(('.xls', '.xlsx'))
                                for part in message.walk() if part.get_filename()
                            )
                            if not has_excel:
                                self.log_failed_email(title, mail_time, "é‚®ä»¶æœ‰é™„ä»¶ä½†æ²¡æœ‰Excelæ–‡ä»¶")
                            else:
                                self.log_failed_email(title, mail_time, "é‚®ä»¶åŒ…å«Excelæ–‡ä»¶ï¼Œä½†å†…å®¹æ— æ³•è§£ææˆ–æ ¼å¼ä¸æ­£ç¡®")
                    else:
                        print('å½“å‰resultå˜é‡å€¼æ˜¯:', result)
                        # æ¸…æ´— result æ•°æ®ï¼Œæå–æœ‰æ•ˆè®°å½•
                        valid_data = []
                        for sublist in result:
                            if isinstance(sublist, list):
                                for item in sublist:
                                    if (isinstance(item, dict) and 
                                        item.get('goods_code') and 
                                        item.get('goods_name') and 
                                        item.get('net_time') and 
                                        item.get('dw_net') and 
                                        item.get('lj_net')):
                                        valid_data.append({
                                            'net_time': self.timeStamp_to_date(item['net_time']),
                                            'goods_code': item['goods_code'],
                                            'goods_name': item['goods_name'],
                                            'dw_net': item['dw_net'],
                                            'lj_net': item['lj_net']
                                        })
                        if valid_data:
                            all_valid_data.extend(valid_data)
                            print(f"æå–åˆ°æœ‰æ•ˆæ•°æ®: {valid_data}")

                            # è¿½åŠ å†™å…¥Excelï¼Œæ¯å°é‚®ä»¶å¤„ç†ä¸€æ¬¡å°±å†™ä¸€æ¬¡
                            output_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'é‚®ä»¶é™„ä»¶å‡€å€¼æŠ“å–.xlsx')
                            df_new = pd.DataFrame(valid_data, columns=['net_time', 'goods_code', 'goods_name', 'dw_net', 'lj_net'])
                            try:
                                if os.path.exists(output_path):
                                    # è¯»å–å·²å­˜åœ¨çš„æ•°æ®ï¼Œè¿½åŠ åå»é‡ï¼ˆå¦‚éœ€å»é‡å¯åŠ ï¼‰
                                    df_existing = pd.read_excel(output_path)
                                    df_combined = pd.concat([df_existing, df_new], ignore_index=True)
                                    # å¯é€‰ï¼šå»é‡
                                    df_combined.drop_duplicates(subset=['net_time', 'goods_code'], inplace=True)
                                else:
                                    df_combined = df_new
                                df_combined.to_excel(output_path, index=False)
                                print(f"æœ‰æ•ˆæ•°æ®å·²è¿½åŠ å†™å…¥Excel: {output_path}")
                            except Exception as e:
                                print(f"å†™å…¥Excelå¤±è´¥: {e}")

                    time.sleep(1)
                    print('=' * 70)
            except Exception as e:
                print(f"get_mailæ–¹æ³•å‘ç”Ÿå¼‚å¸¸: {e}")


        def log_failed_email(self, subject, mail_time, reason):
            """Log failed emails to an Excel file."""
            output_dir = os.path.dirname(os.path.abspath(__file__))
            output_path = os.path.join(output_dir, 'failed_emails.xlsx')
            
            failure_data = {
                'Email Subject': subject,
                'Receiving Time': self.timeStamp_to_date(mail_time) if mail_time else 'Unknown',
                'Failure Reason': reason
            }
            
            df_new = pd.DataFrame([failure_data])
            
            try:
                if os.path.exists(output_path):
                    df_existing = pd.read_excel(output_path)
                    df_combined = pd.concat([df_existing, df_new], ignore_index=True)
                else:
                    df_combined = df_new
                df_combined.to_excel(output_path, index=False)
                self.logger.info(f"Logged failed email '{subject}' to {output_path}")
            except Exception as e:
                self.logger.error(f"Failed to write to failed_emails.xlsx: {e}")


        def update_data(self,lists):
            """æ•°æ®è¿›åº“ï¼Œæ’å…¥ty_cj_net_tqè¡¨"""
            if lists is None or len(lists) <= 0:
                return False
            print('å¾…å…¥åº“å‡€å€¼æ•°æ®:',lists)
            for val in lists:
                if val is None or len(val) <= 0:
                    continue

                for v in val:
                    where_sql = ' WHERE goods_code="'+v['goods_code']+'" and net_time='+str(v['net_time'])
                    check_result = self.db.query_one(TQ_CJ_NET_TABLE,'*',where_sql)
                    if check_result is None:
                        self.db.insert_one(TQ_CJ_NET_TABLE,v)
                    else:
                        self.db.update(TQ_CJ_NET_TABLE, v,where_sql)

    if __name__ == '__main__':
        while True:
            try:
                # æ³¨ï¼šEmailå¯¹è±¡å®ä¾‹åŒ–å¦‚æœæ”¾åœ¨whileå¤–é¢åªä¼šåˆå§‹åŒ–ä¸€æ¬¡é‚®ç®±ç™»å½•ã€æ•°æ®åº“è¿æ¥ã€é‡‡é›†æˆªæ­¢æ—¶é—´è¯»å–ï¼Œä¸ºä¿è¯å¥æŸ„èµ„æºå¯ç”¨æœ€å¥½æ”¾åœ¨å¾ªç¯ä½“å†…ï¼
                email_obj = Email("jz@dingshi.net", "uJLygjCC9sDhxg4q")
                email_obj.get_mail()
                print('æœ¬æ¬¡é‡‡é›†ç»“æŸï¼Œç­‰å¾…10åˆ†é’Ÿåé‡æ–°é‡‡é›†ï¼')
                print('æœ¬æ¬¡é‡‡é›†æ—¶é—´æ˜¯ï¼š')
                print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))
                time.sleep(300)
            except Exception as e:
                print(e)

            </code></pre>
        </div>
    </details>
    <script>
    function copyCode(btn) {
            const pre = btn.parentElement.querySelector('pre code');
            let text = pre.innerText;
            // Remove leading/trailing empty lines
            text = text.replace(/^\s*\n/, '').replace(/\n\s*$/, '');
            // Create a temporary textarea to copy
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                    document.execCommand('copy');
                    btn.textContent = 'å·²å¤åˆ¶!';
                    setTimeout(() => { btn.textContent = 'å¤åˆ¶ä»£ç '; }, 1200);
            } catch (e) {
                    btn.textContent = 'å¤åˆ¶å¤±è´¥';
            }
            document.body.removeChild(textarea);
    }
    </script>

  <h3>rule1.py</h3>
    <details>
        <summary>ç‚¹å‡»å±•å¼€/æŠ˜å ä»£ç </summary>
        <div style="position: relative;">
            <button onclick="copyCode(this)" style="position: absolute; top: 8px; right: 8px; z-index: 2; font-size: 12px; padding: 2px 8px; cursor: pointer;">å¤åˆ¶ä»£ç </button>
            <pre><code>
    <!-- æ›¿æ¢ä¸ºå®é™…æ–‡ä»¶å†…å®¹ -->
    from bs4 import BeautifulSoup
    def chooseMethed(soup: BeautifulSoup, heading: str):
        """
        æ ¹æ®é‚®ä»¶æ ‡é¢˜é€‰æ‹©è§£ææ–¹å¼ã€‚
        è¿”å›ï¼š
            data: list of <td> elements
            cishu: è¡¨å¤´æ‰€åœ¨è¡Œæ•°æˆ–æ ‡å¿—
        """
        # é»˜è®¤å¤„ç†æ–¹å¼
        table = soup.find('table')
        if not table:
            return None, 0

        # æå–æ‰€æœ‰td
        tds = table.find_all('td')

        # æ ¹æ®æ ‡é¢˜çµæ´»åŒ¹é…ä¸åŒæ ¼å¼ï¼ˆå¯æ‰©å±•ï¼‰
        if "äº§å“å‡€å€¼" in heading:
            # ç‰¹æ®Šå¤„ç†äº§å“å‡€å€¼æ ¼å¼ï¼ˆä¾‹ï¼‰
            return tds, 1  # è¡¨å¤´ä¸ºç¬¬ä¸€è¡Œ
        elif "æ¯æ—¥å‡€å€¼" in heading:
            return tds, 0  # è¡¨å¤´ä¸ºç¬¬0è¡Œ
        elif "ä¼°å€¼è¡¨" in heading:
            return tds, 2  # è¡¨å¤´ä¸ºç¬¬2è¡Œ
        else:
            return tds, 1  # é»˜è®¤æƒ…å†µ
            </code></pre>
        </div>
    </details>
    <script>
    function copyCode(btn) {
            const pre = btn.parentElement.querySelector('pre code');
            let text = pre.innerText;
            // Remove leading/trailing empty lines
            text = text.replace(/^\s*\n/, '').replace(/\n\s*$/, '');
            // Create a temporary textarea to copy
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                    document.execCommand('copy');
                    btn.textContent = 'å·²å¤åˆ¶!';
                    setTimeout(() => { btn.textContent = 'å¤åˆ¶ä»£ç '; }, 1200);
            } catch (e) {
                    btn.textContent = 'å¤åˆ¶å¤±è´¥';
            }
            document.body.removeChild(textarea);
    }
    </script>


  <h3>main.py</h3>
    <details>
        <summary>ç‚¹å‡»å±•å¼€/æŠ˜å ä»£ç </summary>
        <div style="position: relative;">
            <button onclick="copyCode(this)" style="position: absolute; top: 8px; right: 8px; z-index: 2; font-size: 12px; padding: 2px 8px; cursor: pointer;">å¤åˆ¶ä»£ç </button>
            <pre><code>
    <!-- æ›¿æ¢ä¸ºå®é™…æ–‡ä»¶å†…å®¹ -->
    # This is a sample Python script.

            # Press Shift+F10 to execute it or replace it with your code.
            # Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.


            def print_hi(name):
                            # Use a breakpoint in the code line below to debug your script.
                            print(f'Hi, {name}')  # Press Ctrl+F8 to toggle the breakpoint.


            # Press the green button in the gutter to run the script.
            if __name__ == '__main__':
                            print_hi('PyCharm')

            # See PyCharm help at https://www.jetbrains.com/help/pycharm/
            </code></pre>
        </div>
    </details>
    <script>
    function copyCode(btn) {
            const pre = btn.parentElement.querySelector('pre code');
            let text = pre.innerText;
            // Remove leading/trailing empty lines
            text = text.replace(/^\s*\n/, '').replace(/\n\s*$/, '');
            // Create a temporary textarea to copy
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                    document.execCommand('copy');
                    btn.textContent = 'å·²å¤åˆ¶!';
                    setTimeout(() => { btn.textContent = 'å¤åˆ¶ä»£ç '; }, 1200);
            } catch (e) {
                    btn.textContent = 'å¤åˆ¶å¤±è´¥';
            }
            document.body.removeChild(textarea);
    }
    </script>


  <h2>ğŸ“¥ é™„ä»¶ä¸‹è½½</h2>
  <ul>
    <li><a href="../assets/email_extract/log_body.docx" download>ç‰ˆæœ¬æ—¥å¿—ï¼ˆæ­£æ–‡ï¼‰.docx</a></li>
    <li><a href="../assets/email_extract/log_atta.docx" download>ç‰ˆæœ¬æ—¥å¿—ï¼ˆé™„ä»¶ï¼‰.docx</a></li>
  </ul>

  <p><a href="../index.html">â† è¿”å›ä¸»é¡µ</a></p>
</body>
</html>
