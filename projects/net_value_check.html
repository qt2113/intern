<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>ğŸ” å‡€å€¼å¼‚å¸¸æ•°æ®æ£€æµ‹ç³»ç»Ÿ</title>
  <link rel="stylesheet" href="../style.css">
  <style>
    body {
      font-family: sans-serif;
      padding: 40px;
      max-width: 900px;
      margin: auto;
    }
    h1 {
      color: #2c3e50;
    }
    pre {
      background: #f4f4f4;
      padding: 15px;
      overflow-x: auto;
      border-left: 4px solid #2980b9;
    }
    code {
      font-family: monospace;
    }
    a {
      color: #2980b9;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>ğŸ” å‡€å€¼å¼‚å¸¸æ•°æ®æ£€æµ‹ç³»ç»Ÿ</h1>
  <ul style = 'list-style-type:disc;'>
    <p>æœ¬é¡¹ç›®ç”¨Pythonå®ç°å¯¹æ ‡çš„å‡€å€¼æ•°æ®çš„å®Œæ•´æ€§å’ŒæŠ«éœ²é¢‘ç‡è‡ªåŠ¨æ£€æµ‹ã€‚æ ¸å¿ƒåŠŸèƒ½åŒ…æ‹¬ï¼š</p>
        <li>- æ£€æŸ¥å‡€å€¼è®°å½•æ˜¯å¦ç¼ºå¤±å…³é”®å­—æ®µï¼ˆæ ‡çš„ä»£ç ã€å‡€å€¼æ—¥æœŸã€å•ä½å‡€å€¼ã€ç´¯è®¡å‡€å€¼ï¼‰ï¼›</li>
        <li>- ç»“åˆèŠ‚å‡æ—¥æ—¥å†ï¼Œåˆ¤æ–­åº”æŠ«éœ²æ—¥æœŸæ˜¯å¦ç¼ºå¤±å‡€å€¼æ•°æ®ï¼Œæ”¯æŒæ—¥é¢‘ã€å‘¨é¢‘ã€æœˆé¢‘å¤šç§é¢‘ç‡æ£€æµ‹;</li>
        <li>- åŠ¨æ€è¯†åˆ«å‡€å€¼æŠ«éœ²é¢‘ç‡ï¼Œæ”¯æŒåŒä¸€æ ‡çš„ä¸åŒæ—¶é—´æ®µé¢‘ç‡å˜åŒ–ï¼›</li>
        <li>- æ¨¡å—åŒ–è®¾è®¡ï¼Œæ•°æ®è¯»å–ã€å®Œæ•´æ€§æ£€æµ‹å’Œé¢‘ç‡ç»Ÿè®¡å‡½æ•°ç‹¬ç«‹ï¼Œä¾¿äºç»´æŠ¤ï¼›æ”¯æŒå®šæ—¶ä»»åŠ¡ï¼Œæ¯5åˆ†é’Ÿè‡ªåŠ¨è¿è¡Œï¼Œå®æ—¶ç›‘æ§æ•°æ®è´¨é‡ï¼›</li>
    </ul>

  <h2>æ“ä½œæµç¨‹ï¼š</h2>
    <ol>
        <li>éå†æ‰€æœ‰æ ‡çš„ä»£ç ï¼Œé€ä¸€æ‰§è¡Œå‡€å€¼å®Œæ•´æ€§å’Œé¢‘ç‡æ£€æµ‹ï¼Œç»“æœç»Ÿä¸€å½’ç±»å¤„ç†ï¼›</li>
        <li>æ£€æµ‹è¿‡ç¨‹ä¸­ï¼Œè‡ªåŠ¨è¯†åˆ«å¹¶æ ‡æ³¨å‡€å€¼æŠ«éœ²çš„é¢‘ç‡ç±»å‹ï¼ˆæ—¥é¢‘ã€å‘¨é¢‘æˆ–æœˆé¢‘ï¼‰ï¼Œæ”¯æŒåŒä¸€æ ‡çš„ä¸åŒæ—¶é—´æ®µé¢‘ç‡äº¤æ›¿å‡ºç°ï¼Œå¹¶è¾“å‡ºç›¸åº”çš„é¢‘ç‡ä¿¡æ¯ï¼›</li>
        <li>æ ¹æ®è¯†åˆ«å‡ºçš„é¢‘ç‡ï¼Œæ£€æµ‹å‡€å€¼æ•°æ®ä¸­æ˜¯å¦å­˜åœ¨ç¼ºå¤±æ—¥æœŸæˆ–åŒºé—´ï¼Œé’ˆå¯¹ç¼ºå¤±æƒ…å†µè¿›è¡Œå¼‚å¸¸è®°å½•åˆ°Excelï¼Œæ–¹ä¾¿åç»­æ’æŸ¥ï¼›</li>
        <li>é¢„å…ˆç”¨ç™¾åº¦æ—¥å†apiæ¥å£ä¸‹è½½æ‰€éœ€å¹´ä»½çš„èŠ‚å‡æ—¥æ—¥å†CSVæ–‡ä»¶åˆ°æœ¬åœ°ï¼Œä¸»ç¨‹åºå†é€šè¿‡è¯»å–æ­¤CSVæ–‡ä»¶åˆ¤æ–­èŠ‚å‡æ—¥ï¼Œé¿å…å°†æ­£å¸¸èŠ‚å‡æ—¥æœŸè¯¯åˆ¤ä¸ºç¼ºå¤±æ•°æ®ï¼›</li>
        <li>æ”¯æŒå°†æ£€æµ‹åŠŸèƒ½è®¾ç½®ä¸ºå®šæ—¶ä»»åŠ¡ï¼Œæ¯éš”5åˆ†é’Ÿè‡ªåŠ¨è¿è¡Œä¸€æ¬¡ï¼Œå®ç°å¯¹å‡€å€¼æ•°æ®çš„æŒç»­åŠ¨æ€ç›‘æ§å’Œå¼‚å¸¸åŠæ—¶å‘ç°ã€‚</li>
    </ol>

  <h3>å‡€å€¼æ£€æµ‹.py</h3>
    <details>
        <summary>ç‚¹å‡»å±•å¼€/æŠ˜å ä»£ç </summary>
        <div style="position: relative;">
            <button onclick="copyCode(this)" style="position: absolute; top: 8px; right: 8px; z-index: 2; font-size: 12px; padding: 2px 8px; cursor: pointer;">å¤åˆ¶ä»£ç </button>
            <pre><code>
    <!-- æ›¿æ¢ä¸ºå®é™…æ–‡ä»¶å†…å®¹ -->
    import pandas as pd
    import numpy as np
    from datetime import datetime, timedelta
    import schedule
    import time
    import os
    #éœ€æ“ä½œè¯»å–æŒ‡å®šè·¯å¾„çš„èŠ‚å‡æ—¥æ—¥å†æ•°æ®ï¼›å‡è®¾èŠ‚å‡æ—¥æ—¥å†æ•°æ®å·²å­˜å‚¨åœ¨ calendar_data.csv ä¸­ï¼›å…·ä½“çš„èŠ‚å‡æ—¥æ•°æ®éœ€è¦è¿è¡Œget_calendar.pyè„šæœ¬è·å–
    calendar_df = pd.read_csv(r"C:\Users\TQY\Desktop\å‡€å€¼æ£€æµ‹\calendar_data.csv", dtype={'year': str, 'month': str, 'day': str})
    calendar_df['date'] = pd.to_datetime(calendar_df['year'] + '-' + calendar_df['month'] + '-' + calendar_df['day'])
    calendar_df['should_check_net_value'] = calendar_df['status'].isin([0, 2]) # æ ‡æ³¨æ˜¯å¦åº”æ£€æµ‹å‡€å€¼çš„æ—¥å­ï¼ˆstatus ä¸º 0 æˆ– 2ï¼‰

    def load_data(file_path='net_value_data.xlsx'):
        if file_path.endswith('.csv'):
            df = pd.read_csv(file_path)
        elif file_path.endswith('.xlsx'):
            df = pd.read_excel(file_path)
        else:
            raise ValueError("ä»…æ”¯æŒcsvæˆ–xlsxæ ¼å¼")

        df.columns = df.columns.str.strip()
        df['å‡€å€¼æ—¥æœŸ'] = pd.to_datetime(df['å‡€å€¼æ—¥æœŸ'])
        df = df.dropna(subset=['æ ‡çš„ä»£ç ', 'å‡€å€¼æ—¥æœŸ'])
        return df


    def infer_frequency_segmented(dates):
        """
        å¯¹å‡€å€¼æ—¥æœŸè¿›è¡Œæ»‘åŠ¨çª—å£é¢‘ç‡æ¨æ–­ï¼Œè¿”å›æ¯æ®µçš„é¢‘ç‡åŠå…¶æ—¶é—´æ®µ
        """
        dates = dates.sort_values().drop_duplicates()
        segments = []
        if len(dates) < 5:
            return [{'start': dates.min(), 'end': dates.max(), 'freq': 'æœªçŸ¥'}]

        window_size = 10
        step = 5
        for i in range(0, len(dates) - window_size + 1, step):
            window = dates[i:i + window_size]
            diffs = window.diff().dt.days.dropna()
            avg_gap = diffs.mean()
            if avg_gap <= 2:
                freq = 'æ—¥é¢‘'
            elif 3 <= avg_gap <= 9:
                freq = 'å‘¨é¢‘'
            elif avg_gap >= 20:
                freq = 'æœˆé¢‘'
            else:
                freq = 'æœªçŸ¥'
            segments.append({
                'start': window.min(),
                'end': window.max(),
                'freq': freq
            })

        # åˆå¹¶ç›¸é‚»ç›¸åŒé¢‘ç‡æ®µ
        merged = []
        for seg in segments:
            if not merged or merged[-1]['freq'] != seg['freq']:
                merged.append(seg)
            else:
                merged[-1]['end'] = seg['end']
        return merged


    def check_completeness(group):
        code = group['æ ‡çš„ä»£ç '].iloc[0]
        group = group.sort_values('å‡€å€¼æ—¥æœŸ')
        dates = group['å‡€å€¼æ—¥æœŸ']
        today = pd.to_datetime('today').normalize()

        # ç¼ºå­—æ®µæ£€æŸ¥
        missing_fields = group[
            group[['å•ä½å‡€å€¼', 'ç´¯è®¡å‡€å€¼', 'å‡€å€¼æ—¥æœŸ', 'æ ‡çš„ä»£ç ']].isnull().any(axis=1)
        ]

        # æ¨æ–­ä¸åŒæ—¶é—´æ®µçš„é¢‘ç‡
        freq_segments = infer_frequency_segmented(dates)
        missing_dates = []

        for seg in freq_segments:
            freq = seg['freq']
            seg_start = seg['start']
            seg_end = seg['end']
            seg_dates = dates[(dates >= seg_start) & (dates <= seg_end)]

            valid_days = calendar_df[
                (calendar_df['date'] >= seg_start) &
                (calendar_df['date'] <= seg_end) &
                (calendar_df['should_check_net_value']) &
                (calendar_df['date'] <= today)
            ]['date']

            if freq == 'æ—¥é¢‘':
                valid_days_filtered = valid_days[valid_days.dt.weekday < 5]
                for d in valid_days_filtered:
                    if d not in seg_dates.values:
                        missing_dates.append(d.strftime('%Y-%m-%d'))

            elif freq == 'å‘¨é¢‘':
                valid_weeks = valid_days.dt.to_period('W').unique()
                actual_weeks = seg_dates.dt.to_period('W').unique()
                for week in valid_weeks:
                    if week not in actual_weeks:
                        week_days = valid_days[valid_days.dt.to_period('W') == week]
                        if (week_days.dt.weekday < 5).sum() >= 3:
                            missing_dates.append(week_days.max().strftime('%Y-%m-%d'))

            elif freq == 'æœˆé¢‘':
                valid_months = valid_days.dt.to_period('M').unique()
                actual_months = seg_dates.dt.to_period('M').unique()
                for month in valid_months:
                    if month not in actual_months:
                        month_days = valid_days[valid_days.dt.to_period('M') == month]
                        if (month_days.dt.weekday < 5).sum() >= 7:
                            missing_dates.append(month_days.max().strftime('%Y-%m-%d'))

            # å…¶ä»–é¢‘ç‡ä¸åšå¤„ç†

        return {
            'æ ‡çš„ä»£ç ': code,
            'é¢‘ç‡æ®µæ•°': len(freq_segments),
            'ç¼ºå¤±å­—æ®µè®°å½•æ•°': len(missing_fields),
            'ç¼ºå¤±æ—¥æœŸæ•°': len(missing_dates),
            'ç¼ºå¤±æ—¥æœŸç¤ºä¾‹': missing_dates[:10]
        }


    def main_check(file_path, target_code=None, output_path=None):
        print(f"\n[{datetime.now()}] å‡€å€¼å®Œæ•´æ€§æ£€æµ‹å¼€å§‹")
        df = load_data(file_path)

        if target_code:
            if target_code not in df['æ ‡çš„ä»£ç '].unique():
                print(f"âŒ æ ‡çš„ä»£ç  '{target_code}' ä¸å­˜åœ¨äºæ•°æ®ä¸­")
                return
            df = df[df['æ ‡çš„ä»£ç '] == target_code]

        all_codes = df['æ ‡çš„ä»£ç '].unique()
        incomplete_list = []

        for code in all_codes:
            group = df[df['æ ‡çš„ä»£ç '] == code].copy()
            result = check_completeness(group)
            print(f"\næ ‡çš„ä»£ç ï¼š{result['æ ‡çš„ä»£ç ']}")
            print(f"é¢‘ç‡æ®µæ•°ï¼š{result['é¢‘ç‡æ®µæ•°']}")
            if result['ç¼ºå¤±å­—æ®µè®°å½•æ•°'] > 0 or result['ç¼ºå¤±æ—¥æœŸæ•°'] > 0:
                print(f"â—ç¼ºå¤±å­—æ®µè®°å½•æ•°ï¼š{result['ç¼ºå¤±å­—æ®µè®°å½•æ•°']}")
                print(f"â—ç¼ºå¤±æ—¥æœŸæ•°ï¼š{result['ç¼ºå¤±æ—¥æœŸæ•°']}")
                print(f"â—ç¼ºå¤±æ—¥æœŸç¤ºä¾‹ï¼š{result['ç¼ºå¤±æ—¥æœŸç¤ºä¾‹']}")
                incomplete_list.append(result)
            else:
                print("âœ… å‡€å€¼æ•°æ®å®Œæ•´")

        print("\n--- æ£€æµ‹ç»“æŸ ---")

        if incomplete_list:
            out_df = pd.DataFrame(incomplete_list)
            out_df['ç¼ºå¤±æ—¥æœŸç¤ºä¾‹'] = out_df['ç¼ºå¤±æ—¥æœŸç¤ºä¾‹'].apply(lambda x: ', '.join(x))

            if output_path is None:
                base_dir = os.path.dirname(file_path)
                output_path = os.path.join(base_dir, 'å‡€å€¼å¼‚å¸¸æ•°æ®.xlsx')
            out_df.to_excel(output_path, index=False)
            print(f"\nç¼ºå¤±ä¿¡æ¯å·²ä¿å­˜è‡³ï¼š{output_path}")
        else:
            print("\næ‰€æœ‰æ ‡çš„å‡€å€¼æ•°æ®å®Œæ•´ï¼Œæ— ç¼ºå¤±ã€‚")
            # è‹¥æ— å¼‚å¸¸æ•°æ®ï¼Œä»ç„¶è¦†ç›–è¾“å‡ºæ–‡ä»¶ä¸ºç©ºè¡¨
            if output_path is None:
                base_dir = os.path.dirname(file_path)
                output_path = os.path.join(base_dir, 'å‡€å€¼å¼‚å¸¸æ•°æ®.xlsx')
            pd.DataFrame(columns=['æ ‡çš„ä»£ç ', 'é¢‘ç‡æ®µæ•°', 'ç¼ºå¤±å­—æ®µè®°å½•æ•°', 'ç¼ºå¤±æ—¥æœŸæ•°', 'ç¼ºå¤±æ—¥æœŸç¤ºä¾‹']).to_excel(output_path, index=False)
            print(f"\nè¾“å‡ºæ–‡ä»¶å·²æ¸…ç©ºï¼š{output_path}")


    def setup_schedule(interval_min=5, file_path='net_value_data.xlsx'):
        base_dir = os.path.dirname(file_path)
        output_path = os.path.join(base_dir, 'å‡€å€¼å¼‚å¸¸æ•°æ®.xlsx')
        schedule.every(interval_min).minutes.do(main_check, file_path=file_path, output_path=output_path)
        print(f"\n[å®šæ—¶æ£€æµ‹å·²å¯åŠ¨ï¼Œæ¯{interval_min}åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡]")
        while True:
            schedule.run_pending()
            time.sleep(1)

    if __name__ == '__main__':
        # å¯åŠ¨ä¸€æ¬¡ç«‹å³æ£€æµ‹
        # main_check(file_path = r"C:\Users\TQY\Desktop\to_goods_net.xlsx", target_code='', output_path=r"C:\Users\TQY\Desktop\å‡€å€¼å¼‚å¸¸æ•°æ®.xlsx") # æ£€æµ‹ç‰¹å®šæ ‡çš„ä»£ç 
        main_check(file_path = r"C:\Users\TQY\Desktop\å‡€å€¼æ£€æµ‹\to_goods_net.xlsx", output_path=r"C:\Users\TQY\Desktop\å‡€å€¼æ£€æµ‹\å‡€å€¼å¼‚å¸¸æ•°æ®.xlsx")  #æ£€æµ‹æ‰€æœ‰æ ‡çš„ä»£ç 

        #ç„¶åæ¯5åˆ†é’Ÿå®šæ—¶æ‰§è¡Œ
        setup_schedule(5, r"C:\Users\TQY\Desktop\å‡€å€¼æ£€æµ‹\to_goods_net.xlsx")

            </code></pre>
        </div>
    </details>
    <script>
    function copyCode(btn) {
            const pre = btn.parentElement.querySelector('pre code');
            let text = pre.innerText;
            // Remove leading/trailing empty lines
            text = text.replace(/^\s*\n/, '').replace(/\n\s*$/, '');
            // Create a temporary textarea to copy
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                    document.execCommand('copy');
                    btn.textContent = 'å·²å¤åˆ¶!';
                    setTimeout(() => { btn.textContent = 'å¤åˆ¶ä»£ç '; }, 1200);
            } catch (e) {
                    btn.textContent = 'å¤åˆ¶å¤±è´¥';
            }
            document.body.removeChild(textarea);
    }
    </script>

  <h3>get_calendar.py</h3>
    <details>
        <summary>ç‚¹å‡»å±•å¼€/æŠ˜å ä»£ç </summary>
        <div style="position: relative;">
            <button onclick="copyCode(this)" style="position: absolute; top: 8px; right: 8px; z-index: 2; font-size: 12px; padding: 2px 8px; cursor: pointer;">å¤åˆ¶ä»£ç </button>
            <pre><code>
    <!-- æ›¿æ¢ä¸ºå®é™…æ–‡ä»¶å†…å®¹ -->
   '''æ­¤ä»£ç ç”¨äºä»ç™¾åº¦æ¥å£æŠ“å–èŠ‚å‡æ—¥æ—¥å†æ•°æ®ï¼Œå¹¶ä¿å­˜ä¸ºCSVæ–‡ä»¶ã€‚'''
    import requests as req
    import datetime
    import json
    import random
    import time
    import pandas as pd
    import os

    # ä¿å­˜çš„CSVæ–‡ä»¶å
    CALENDAR_CSV = "calendar_data.csv"

    # ä»ç™¾åº¦æ¥å£ä¸­è·å–èŠ‚å‡æ—¥æ—¥å†æ•°æ®
    class Calendar:

        def __init__(self):
            self.dataTime = str(random.random())
            self.header = {
                "Content-Type": "application/json;charset=UTF-8"
            }
            self.param = {
                "query": '',
                "resource_id": "39043",
                "t": self.dataTime,
                "ie": "utf8",
                "oe": "gbk",
                "format": "json",
                "tn": "wisetpl",
                "cb": ""
            }

            if os.path.exists(CALENDAR_CSV):
                self.df = pd.read_csv(CALENDAR_CSV, dtype={"year": str, "month": str, "day": str})
            else:
                self.df = pd.DataFrame(columns=[
                    'year', 'month', 'day', 'timestamp', 'status',
                    'cnDay', 'festival', 'is_sd', 'is_trading'
                ])

        def time_to_fmt(self, times, fmt='%Y-%m-%d %H:%M:%S'):
            """æŠŠæ—¶é—´æˆ³è½¬æˆæ—¥æœŸæ ¼å¼"""
            now = int(times)
            time_arr = time.localtime(now)
            fmt_time = time.strftime(fmt, time_arr)
            return fmt_time

        def save_calendar(self):
            """ä¿å­˜ DataFrame åˆ° CSV æ–‡ä»¶"""
            self.df.to_csv(CALENDAR_CSV, index=False)
            print(f"å·²ä¿å­˜è‡³ {CALENDAR_CSV}")

        def catch_url_from_baidu(self, calcultaion_year, month):
            """ä»ç™¾åº¦æ¥å£æŠ“å–æŒ‡å®šå¹´æœˆçš„æ—¥å†ä¿¡æ¯"""
            self.param['query'] = f"{calcultaion_year}å¹´{month}æœˆ"
            print(f"æŠ“å–ç™¾åº¦æ—¥å†ï¼š{self.param['query']}...")

            r = req.get(
                url="https://sp0.baidu.com/8aQDcjqpAAV3otqbppnN2DJv/api.php",
                headers=self.header,
                params=self.param
            ).text

            month_data = json.loads(r)["data"][0]["almanac"]

            for data in month_data:
                insert_data = {
                    'year': str(data['year']),
                    'month': str(data['month']),
                    'day': str(data['day']),
                    'timestamp': int(data['timestamp']),
                    'status': int(data['status']) if 'status' in data else 0,
                    'cnDay': data['cnDay'],
                    'festival': data.get('festival', ''),
                    'is_sd': 0,
                    'is_trading': 0
                }

                # åˆ¤æ–­æ˜¯å¦å·²å­˜åœ¨ï¼ˆæŒ‰å¹´æœˆæ—¥æŸ¥é‡ï¼‰
                mask = (
                    (self.df['year'] == insert_data['year']) &
                    (self.df['month'] == insert_data['month']) &
                    (self.df['day'] == insert_data['day'])
                )

                if mask.any():
                    self.df.loc[mask, list(insert_data.keys())] = list(insert_data.values())
                    print(f"{insert_data['year']}-{insert_data['month']}-{insert_data['day']} | æ›´æ–°æˆåŠŸ")
                else:
                    self.df = pd.concat([self.df, pd.DataFrame([insert_data])], ignore_index=True)
                    print(f"{insert_data['year']}-{insert_data['month']}-{insert_data['day']} | æ–°å¢æˆåŠŸ")

        def find_trading(self):
            """æ ‡è®°äº¤æ˜“æ—¥ï¼šå·¥ä½œæ—¥ä¸”éå‘¨å…­æ—¥"""
            df = self.df.copy()
            df = df[df['status'] == 0]
            df = df[~df['cnDay'].isin(['å…­', 'æ—¥'])]

            for idx, row in df.iterrows():
                ts = int(row['timestamp'])
                date_obj = datetime.date.fromtimestamp(ts)
                ts_normalized = int(time.mktime(date_obj.timetuple()))
                self.df.loc[self.df['timestamp'] == ts, 'is_trading'] = 1

            print("äº¤æ˜“æ—¥æ›´æ–°å®Œæˆï¼")
            self.save_calendar()


    if __name__ == '__main__':
        # åªæ‰§è¡Œä¸€æ¬¡ï¼Œè·å–2023~2025çš„æ•°æ®
        obj = Calendar()
        for year in [2019, 2020, 2021, 2022, 2023, 2024, 2025]: #å¯è‡ªå®šä¹‰éœ€è¦æŠ“å–çš„å¹´ä»½æ•°æ®
            for month in ["2", "5", "8", "11"]:
                obj.catch_url_from_baidu(year, month)
                time.sleep(1)

        obj.find_trading()
        print("å†å²èŠ‚å‡æ—¥æŠ“å–å®Œæ¯•ï¼è¿è¡Œæ—¶é—´ï¼š", obj.time_to_fmt(time.time()))

            </code></pre>
        </div>
    </details>
    <script>
    function copyCode(btn) {
            const pre = btn.parentElement.querySelector('pre code');
            let text = pre.innerText;
            // Remove leading/trailing empty lines
            text = text.replace(/^\s*\n/, '').replace(/\n\s*$/, '');
            // Create a temporary textarea to copy
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                    document.execCommand('copy');
                    btn.textContent = 'å·²å¤åˆ¶!';
                    setTimeout(() => { btn.textContent = 'å¤åˆ¶ä»£ç '; }, 1200);
            } catch (e) {
                    btn.textContent = 'å¤åˆ¶å¤±è´¥';
            }
            document.body.removeChild(textarea);
    }
    </script>

  <h2>ğŸ“¥ ç‚¹å‡»é“¾æ¥ä¸‹è½½è¿è¡Œç¤ºä¾‹</h2>
  <ul>
    <li><a href="../assets/net_value_check/to_goods_net.xlsx" download>to_goods_net.xlsx</a></li>
    <li><a href="../assets/net_value_check/net_val_failed.xlsx" download>å‡€å€¼å¼‚å¸¸æ•°æ®.xlsx</a></li>
    <li><a href="../assets/net_value_check/net_val_requirement.docx" download>å‡€å€¼æ£€æµ‹_éœ€æ±‚æ–‡æ¡£.docx</a></li>
  <p><a href="../intern_website.html">â† è¿”å›ä¸»é¡µ</a></p>
</body>
</html>
